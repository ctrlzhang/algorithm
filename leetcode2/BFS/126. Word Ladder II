class Solution {
public:
    //单广
    //本题套路模版:level order，遍历过的节点直接从set中删除掉
    //然后查看当前节点所能转换为的邻接节点是否在剩余字典列表中
    //如果存在，则加入队列，如果不存在则直接跳过，如果是计算所有的路径，则需要保存parent关系,
    //同时要使用set来帮助去除重复的顶点，虽然顶点去重复了，但是parent数组中是有记录该节点父子关系
    //只要保存了父子关系，最终进行dfs时，也就不会丢失路径了
    //或者选择保存children数组
    //这里需要注意的是，当前层有元素找到终点时，需要先标记找到了终点，但是当前层还是需要执行完，才可以退出
    //因为这道题要求是输出所有路径，如果只是输出最短路径长度，那么是可以直接退出，返回结果的
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        //use single path bfs to create a graph
        vector<vector<string>> ans = {};
        unordered_map<string, vector<string>> children;
        unordered_set<string> dict(wordList.begin(), wordList.end());
        if (!dict.count(endWord)) return ans;
        unordered_set<string> curSet;
        curSet.insert(beginWord);
        bool found = false;
        while (!curSet.empty() && !found) {
            for (string s : curSet) {
                dict.erase(s);
            }
            
            //保存下次遍历的set
            unordered_set<string> nextSet;
            for (string org : curSet) {
                string cur = org;
                for (int j = 0; j < cur.size(); j++) {
                    char old = cur[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == old) continue;
                        cur[j] = c;
                        if (!dict.count(cur)) continue;
                        if (cur == endWord) {
                            found = true;
                            children[org].push_back(cur);
                        } else {
                            nextSet.insert(cur);
                            children[org].push_back(cur);
                        }
                    }
                    cur[j] = old;
                }
            }
            swap(curSet, nextSet);
        }
        
        if (found) {
            vector<string> path = {beginWord};
            dfs(beginWord, endWord, wordList, children, path, ans);
        }
        
        return ans;
    }
    
    
    void dfs(string beginWord, string endWord, 
             const vector<string>& wordList, 
             const unordered_map<string, vector<string>>& children,
            vector<string>& path, vector<vector<string>>& ans) {
        //cout<<" xxx="<<beginWord<<"=xxxx"<<endl;
        if (beginWord == endWord) {
            ans.push_back(path);
            return;
        }
        
        if (children.find(beginWord) == children.end()) return;
        
        for (string word : children.at(beginWord)) {
            //cout<<" wxxx="<<word<<"=wxxxx"<<endl;
            path.push_back(word);
            dfs(word, endWord, wordList, children, path, ans);
            path.pop_back();
        }
    }
};


class Solution {
public:
    //双广
    //本题因为需要记录解的路径，所以我们需要构建parent或者children数组
    //跟单广方式一样，我们还是每一步bfs时，先把上一层的元素都从dict数组中删除掉，目的是当前层转换时，不会再转换出
    //已经转换过的点，因为如果再得出原来走过的点，则肯定不是最短路径，没有意义
    //同时，我们不使用queue来保存每一层元素，而是使用set，利用set去重复的特性，这样在遇到重复节点时，不需要担心
    //会有多个节点，其实是将重复和补充付的情况统一处理了，每次insert新节点时，构建parent或children数组
    //在单广时，我们只需要从一个方向去遍历，而在双广时，因为是两个方向，所以父子节点的关系也需要维护下，
    //例如 从左到右遍历时，左为父右为子，从右向左时，也是如此，需要注意下构建数组时，谁是父谁是子
    //诸如此类的问题，我们可以通过标准化，是问题得到简化，例如: 正向和反向set的交替，我们可以初始时，让两个set
    //大小相同，然后每次去小的来bfs, 这样就可以实现交替，同样，正反父子的判断，我们可以利用一个bool变量，使用
    //bool = !bool，交替变换bool的值，这样实现了方向的转换.
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> dict(wordList.begin(), wordList.end());
        vector<vector<string>> ans = {};
        if (!dict.count(endWord)) return ans;
        unordered_map<string, vector<string>> children;
        unordered_set<string> aq;
        unordered_set<string> bq;
        aq.insert(beginWord);
        bq.insert(endWord);
        bool found = false;
        bool left = true;
        while (!aq.empty() && !bq.empty() && !found) {
            for (string s : aq) {
                dict.erase(s);
            }
            
            for (string s : bq) {
                dict.erase(s);
            }
            
            unordered_set<string> nextSet;
            
            //变换方向, 每次都要变换
            swap(aq, bq);
            left = !left;
            
            /*
            cout<<"aq=";
            for (string s : aq) {
                cout<<s<<" ";
            }
            cout<<endl;
            
            cout<<"bq=";
            for (string s : bq) {
                cout<<s<<" ";
            }
            cout<<endl;
            */
            
            for (string org : aq) {
                string cur = org;
                for (int i = 0; i < cur.size(); i++) {
                    char old = cur[i];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == old) continue;
                        cur[i] = c;
                        //双向需要先判断是否在对方的结果里
                        if (bq.count(cur)) {
                            found = true;
                            if (left) {
                                children[org].push_back(cur);
                            } else {
                                children[cur].push_back(org);
                            }
                        } else {
                            if (!dict.count(cur)) continue;
                            if (left) {
                                children[org].push_back(cur);
                            } else {
                                children[cur].push_back(org);
                            }
                            //cout<<"cur="<<cur<<" org="<<org<<endl;
                            nextSet.insert(cur);
                        }
                    }
                    cur[i] = old;
                }
            }
            
            //cout<<"1"<<endl;
            swap(aq, nextSet);
        }
        
        /*
        for (auto& it : children) {
            cout<<"key="<<it.first<<endl;
            for (string val : it.second) {
                cout<<val<<" ";
            }
            cout<<endl;
        }
        */
        
        if (found) {
            //cout<<"2"<<endl;
            vector<string> path = {beginWord};
            dfs(beginWord, endWord, path, wordList, children, ans);
        }
        
        return ans;
    }
    
    void dfs(string beginWord, string endWord, vector<string>& path,
            const vector<string>& wordList, 
            const unordered_map<string, vector<string>>& children,
            vector<vector<string>>& ans) {
        //cout<<"begin="<<beginWord<<endl;
        if (beginWord == endWord) {
            ans.push_back(path);
            return;
        }
        
        if (children.find(beginWord) == children.end()) return;
        
        for (string word : children.at(beginWord)) {
            //cout<<"word="<<word<<endl;
            path.push_back(word);
            dfs(word, endWord, path, wordList, children, ans);
            path.pop_back();
        }
    }
};
