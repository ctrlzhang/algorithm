O(N*M) N 节点数 M 边数
hungarian algo

template

for (int i = 1; i <= n; i++) {
	// init array
	init visited array
	if (dfs(i)) ++ans;
}
return ans;


//在本次查询中还没有被访问过, 这是因为增广路径的查询规则是
//如果两个点尝试匹配时，发现一方已经有主了，那么就会找到这个主
//问问他能不能再重新找个匹配的, 所以是倒着来的
//所以, 我们需要维护一个visited数组, 标识之前的点已经访问
//过了, 我们不会再考虑匹配它, 而是挑选其它的未匹配点, 
//同理, 如果这个主挑了另外一个点, 然后这个点也有主了, 那么
//继续找这个点的主， 然后问问这个新的主能不能重新匹配一个
//不能则return False, 能的话,return true
//这样增广路就又多了一条边, 总之思路就是这样
//交替查询, 维护visited数组, 以及之前的prev关系
boolean dfs(int x) {
	for y in edges(x,y):
		// 已经visited过的, 表示是从前面回溯过来的, 它已经有主了, 需要你换一个匹配对象
		if (visited[y] == false) {
			visited[y] = true // 标记尝试建立关系
			if (prev[y] == -1 || dfs(prev[y])) {
				//如果y没有和其它节点匹配，那么我们可以考虑
				//或者y有主了, 我们找到这个主, 让这个主去重新匹配一个对象, dfs(prev[y]), 
				//如果可以匹配到, 则继续, 否则不成立
				prev[y] = x;
				return true;
			}
		}
	return false;
}

//visited - 仅仅指本次查询路径中的数组, 还是说全局查找路径中的数组
//如果是图的遍历, 那么就是全局的visited数组
//如果是每次都要重新进来的, 那么可能就是局部的visited数组

//增广路查询 augment path
//交替的
//visited[] 每次查询的时候需要初始化一遍, 因为不是全局的, 从全局的轮次看,后面的点可能会访问之前走过的点,
//如果遇到走过的点,会追溯到它的主, 尝试重新让主进行匹配, 所以此时visited[] 在每一轮都是新的
//但是我们需要维护perv, 这样才可以找到之前的主,
//dfs(x) 就是用来判断, 主x能否找到一个匹配点

//依次并入每一个点, 因为是两两匹配, 不会出现重叠的点, 所以是从
//未匹配的点里挑一个进行判断, 这是一个优化, 当然你也可以直接依次遍历所有点
//也是可以得到相同的结果




