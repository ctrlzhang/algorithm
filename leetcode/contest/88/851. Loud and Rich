class Node {
    public:
        int id;
        int quiet;
        Node(int id, int quiet) : id(id), quiet(quiet) {
            
        }
};

class myComp {
    public:
        bool operator() (const Node& l, const Node& r) const {
            return l.quiet > r.quiet;
        }
};

class Solution {
public:
    //use map, and priority_queue
    typedef priority_queue<Node, vector<Node>, myComp> pq;
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        unordered_map<int, pq> data;
        for (vector<int> v : richer) {
            int quietNum = quiet[v[1]];
            Node tmp(v[0], quietNum);
            data[v[1]].push(tmp);
        }
        
        vector<int> ans;
        for (int i = 0; i < quiet.size(); i++) {
            Node cur = data[i].top();
            ans.push_back(cur.id);
        }
        return ans;
    }
};
