class Solution {
public:
    //从每一个病毒节点开始遍历
    //计算出他能影响的病毒节点个数
    //最终从里面选出 直接影响节点个数最多的 节点
    unordered_map<int, vector<int>> parent;
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> cnt(n, 0);
        /*
        for (int d : initial) {
            bfs(d, graph, initial);
        }
        */

        for (int d : initial) {
            parent[d].push_back(d);
        }
        
        for (int d : initial) {
            vector<bool> visited(n, false);
            for (int k : initial) {
                visited[k] = true;
            }
            
            int root = d;
            dfs(root, d, graph, visited);
        }
        
        for (auto& it : parent) {
            if (it.second.size() == 1) {
                cnt[it.second[0]]++;
            }
        }
        
        /*
        for (auto& it : parent) {
            for (int d : it.second) {
                cout<<d<<"";
            }
            cout<<endl;
        }
        */
        
        int bestPos = 0;
        int bestCnt = 0;
        for (int i = 0; i < cnt.size(); i++) {
            if (cnt[i] > bestCnt) {
                bestPos = i;
                bestCnt = cnt[i];
            }
        }
        
        return bestPos;
    }
    
    //bfs
    void bfs(int x, vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> visited(n, false);
        for (int d : initial) {
            visited[d] = true;
        }
        
        //考虑如果该节点和任何边都不相邻,则此时删除该节点是最有的选择
        parent[x].push_back(x);
        queue<int> q;
        q.push(x);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int i = 0; i < n; i++) {
                if (visited[i] == true) continue;
                if (graph[cur][i] == 1) {
                    visited[i] = true;
                    q.push(i);
                    parent[i].push_back(x);
                }
            }
        }
    }
    
    void dfs(int root, int cur, vector<vector<int>>& graph, vector<bool>& visited) {
        for (int i = 0; i < graph.size(); i++) {
            if (visited[i] == true) continue;
            if (graph[cur][i] == 1) {
                visited[i] = true;
                parent[i].push_back(root);
                dfs(root, i, graph, visited);
            }
        }
    }
};
