class Solution {
public:
    //从每一个病毒节点开始遍历
    //计算出他能影响的病毒节点个数
    //最终从里面选出 直接影响节点个数最多的 节点
    //O(n) 一次遍历后,建立父子关系,直接根据父子关系推断出结果
    unordered_map<int, vector<int>> parent;
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> cnt(n, 0);
        /*
        for (int d : initial) {
            bfs(d, graph, initial);
        }
        */

        for (int d : initial) {
            parent[d].push_back(d);
        }
        
        for (int d : initial) {
            vector<bool> visited(n, false);
            for (int k : initial) {
                visited[k] = true;
            }
            
            int root = d;
            dfs(root, d, graph, visited);
        }
        
        for (auto& it : parent) {
            if (it.second.size() == 1) {
                cnt[it.second[0]]++;
            }
        }
        
        /*
        for (auto& it : parent) {
            for (int d : it.second) {
                cout<<d<<"";
            }
            cout<<endl;
        }
        */
        
        int bestPos = 0;
        int bestCnt = 0;
        for (int i = 0; i < cnt.size(); i++) {
            if (cnt[i] > bestCnt) {
                bestPos = i;
                bestCnt = cnt[i];
            }
        }
        
        return bestPos;
    }
    
    //bfs
    void bfs(int x, vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> visited(n, false);
        for (int d : initial) {
            visited[d] = true;
        }
        
        //考虑如果该节点和任何边都不相邻,则此时删除该节点是最有的选择
        parent[x].push_back(x);
        queue<int> q;
        q.push(x);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int i = 0; i < n; i++) {
                if (visited[i] == true) continue;
                if (graph[cur][i] == 1) {
                    visited[i] = true;
                    q.push(i);
                    parent[i].push_back(x);
                }
            }
        }
    }
    
    void dfs(int root, int cur, vector<vector<int>>& graph, vector<bool>& visited) {
        for (int i = 0; i < graph.size(); i++) {
            if (visited[i] == true) continue;
            if (graph[cur][i] == 1) {
                visited[i] = true;
                parent[i].push_back(root);
                dfs(root, i, graph, visited);
            }
        }
    }
};


//暴力解法O(n^2)
//模拟出剔除某个节点后，所能得到的结果，取最优
class Solution {
public:
    //这是一个常规的dfs或者bfs的解法
    //若不删除节点和其联系的边, 通过dfs或者bfs可以得到最终所有感染的节点
    //现在即为,假设删除某一个点和其相邻的边,则看下其一共可以感染的节点个数，取感染节点数最少的那个节点
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int bestPos = 0;
        int bestCnt = INT_MAX;
        for (int d : initial) {
            /*
            //if delete d, use dfs or bfs to calculate nodes number
            vector<bool> visited(n, false);
            for (int x : initial) {
                if (visited[x]) continue;
                if (x == d) continue;
                dfs(x, d, graph, visited);
            }
            
            int tmp = 0;
            for (int i = 0; i < n; i++) {
                tmp += visited[i];
            }
            
            if (tmp < bestCnt || (tmp == bestCnt && d < bestPos)) {
                bestPos = d;
                bestCnt = tmp;
            }
            */
            
            int cnt = bfs(d, graph, initial);
            if (cnt < bestCnt || (cnt == bestCnt && d < bestPos)) {
                bestCnt = cnt;
                bestPos = d;
            }
        }
        
        return bestPos;
    }
    
    void dfs(int x, int src, vector<vector<int>>& graph, vector<bool>& visited) {
        visited[x] = true;
        for (int i = 0; i < graph.size(); i++) {
            if (visited[i]) continue;
            if (graph[x][i] == 0) continue;
            if (i == src) continue;
            dfs(i, src, graph, visited);
        }
    }
    
    int bfs(int d, vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        queue<int> q;
        vector<bool> visited(n, false);
        for (int x : initial) {
            if (x == d) continue;
            q.push(x);
            visited[x] = true;
        }
        
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int i = 0; i < n; i++) {
                if (visited[i]) continue;
                if (i == d) continue;
                if (graph[cur][i] == 0) continue;
                visited[i] = true;
                q.push(i);
            }
        }
        
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += visited[i];
        }
        
        return sum;
    }
};
