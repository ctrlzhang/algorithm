class Node {
    public:
        int id;
        int val;
    
        Node(int id, int val) : id(id), val(val) {
            
        }
    
        bool operator < (const Node& other) {
            return val < other.val;
        }
};

class Solution {
public:
    //slide window
    //left, right, map<int, int>
    //sort
    int smallestRangeII(vector<int>& A, int K) {
        if (A.empty()) return 0;
        
        vector<Node> data;
        int i = 0;
        for (int d : A) {
            Node one(i, d + K);
            Node two(i, d - K);
            data.push_back(one);
            data.push_back(two);
            ++i;
        }
        
        sort(data.begin(), data.end());
        
        /*
        for (Node d : data) {
            cout<<"("<< d.id<<" "<<d.val<<")";
        }
        cout<<endl;
        */
        
        int left = 0, right = 0;
        unordered_map<int, int> mp;
        int end = data.size();
        int ans = INT_MAX;
        while (right < end) {
            //right往前走
            while (right < end && mp.size() < A.size()) {
                Node cur = data[right];
                if (mp.find(cur.id) == mp.end()) {
                    mp[cur.id] = 0;
                }
                
                mp[cur.id]++;
                ++right;
            }
            
            //left往前走
            int prevRight = right - 1;
            while (left <= prevRight && mp.size() == A.size()) {
                int tmpRst = data[prevRight].val - data[left].val;
                //cout<<"tmpRst="<<tmpRst<<endl;
                ans = min(ans, tmpRst);
                Node cur = data[left];
                mp[cur.id]--;
                if (0 == mp[cur.id]) {
                    mp.erase(cur.id);
                }
                ++left;
            }
        }
        
        return ans;
    }
};


//one pass
class Node {
    public:
        int id;
        int val;
        Node(int id, int val) : id(id), val(val) {
            
        }
    
        bool operator < (const Node& other) const {
            return val < other.val;
        }
};

class Solution {
public:
    //slide window
    int smallestRangeII(vector<int>& A, int K) {
        //edge case
        int n = A.size();
        if (0 == n) return 0;
        
        //
        vector<Node> data;
        int left = 0, right = 0, ans = INT_MAX, idx = 0;
        for (int d : A) {
            Node one(idx, d + K);
            Node two(idx, d - K);
            data.push_back(one);
            data.push_back(two);
            ++idx;
        }
        
        sort(data.begin(), data.end());
        unordered_map<int, int> mp;
        
        while (right < data.size()) {
            //go right
            while (right < data.size() && mp.size() < n) {
                Node cur = data[right];
                if (mp.find(cur.id) == mp.end()) {
                    mp[cur.id] = 0;
                }
                
                mp[cur.id]++;
                ++right;
            }
            
            int prev = right - 1;
            
            //go left
            while (left <= prev && mp.size() == n) {
                int tmp = data[prev].val - data[left].val;
                ans = min(ans, tmp);
                int curId = data[left].id;
                mp[curId]--;
                if (0 == mp[curId]) {
                    mp.erase(curId);
                }
                ++left;
            }
        }
        
        return ans;
    }
};
