单调栈
- 用于求解距离当前元素最近的，比当前元素大或者小的第一个元素
- 单调栈中保存下标会比较好处理, 因为根下标可以解决重复元素的问题，同时方便计算出所找到的第一个值和当前值的距离
- 时间复杂度o(N) 空间复杂度O(N)

回文子串
- 中心扩展法, 找到中心, 然后左右扩展

BFS
- 通常用于求最短距离, 以及通过状态转换找元素
- BFS是一层层的扫描, 所以找值或者最短路径是, 通常不需要全扫
- 注意visited数组的使用
- step的使用
- 双向bfs可以使用set来实现, 但是visited数组一定要后设置, 因为双向dfs需要判断两个set里是否有出现重复元素,
如果先设置visited状态，会使得重复元素无法进到set里，导致判断不到
- 双向bfs可以用新建一个tmp set的方式来交换队列

DFS
- 代码好写, 空间复杂度比bfs低，但是通常需要全扫

回溯
- 确定选项是哪些
- 选择
- 不选择
- 恢复
- 确定终止条件

DP
- 确定当前有什么状态, 可以根据状态元素构造递推式
- 确定有哪些选择可能, 根据选择构造递推式
- 确定base case
- 确定目标解是什么, 即dp数组中值的含义是什么
- 通常维度不超过三维
- 通常用于求最值等优化问题

最近刷的题目的总结
1.正则表达式的解法在于如何判定匹配
. 和 *, . 比较容易判断, * 的判断策略是, 需要先看前一位是否match
首先我们得出前一位是否match, 然后再看第二位是否是*
前一位是否match的判断方法是, 看两个字符是否相同或者pattern中的字符是否是.
假设遇到的模式串长度大于等于2，且第二位是通配符, 此时有两种匹配策略
1）让通配符匹配空, 此时继续模式串缩小2, 文本串保持不变, 继续匹配
2) 让通配符去匹配一个字符, (我们的策略不是立马匹配多个, 而是一个一个匹配), 如果第一个文本的字符和模式的字符匹配, 那么模式串保持不变，文本串缩小1， 这就是一个一个匹配的思路
即模式串不动, 文本串缩小1. 如果文本和模式串首字符不匹配, 则模式串这步只能匹配空串, 跟我们第一种选项相同. 
所以 1 和 2 只需要进行或运算即可.
细节即: 考虑文本串空，非空, 模式串空和非空 四种可能.
模式串空, 文本串空 匹配成功
模式串空, 文本串非空 匹配失败
模式串不空, 文本串空, 不一定, 因为 a*b* 可以匹配空串, 需要判断模式串前两位是否为a*的格式, 是则缩小模式串，继续匹配算法, 不是则匹配失败
模式串不空, 文本串不空, 不一定, 这里按照我们的逻辑, 策略即为先判断第一位是否match, 然后判断模式串前两位是否是a*的模式, 如果是, 则可以选择让模式串匹配空和匹配非空

