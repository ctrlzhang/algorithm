/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 /**
  * 思路: 多路归并, 利用K大小的最小堆, 依次出堆
  */
  
bool isLess(ListNode* l, ListNode* r) {
    return l->val < r->val;
}

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        //1.构造K大小的小顶堆, 初始元素为各个链表的表头
        int k = lists.size();
        if(0 == k) return NULL;
        
        vector<ListNode*> heap;
        for(int i=0; i<k; i++) {
            if(NULL != lists[i]) {
                heap.push_back(lists[i]);
            }
        }
        
        make_heap(heap.begin(), heap.end(), isLess);
        
        ListNode* newHead = NULL;
        ListNode* cur = NULL;
        ListNode* curTop = NULL;
        ListNode* next = NULL;
        
        ListNode* output;
        int count = 0;
        while(heap.size() > 0) {
            count++;
            curTop = heap.front();
            next = curTop->next;
            curTop->next = NULL;
            
            if(NULL == newHead) {
                newHead = curTop;
                cur = newHead;
            } else {
                cur->next = curTop;
                cur = cur->next;
            }

            //出堆
            pop_heap(heap.begin(), heap.end());
            heap.pop_back();
            if(3 == count) {
                //return heap.front();
            }
            
            //入堆
            if(NULL != next) {
                heap.push_back(next);
                make_heap(heap.begin(), heap.end());
            }
            
            if(3 == count) {
                //return heap.front();
            }
        }
        
        return newHead;
    }
};

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(0 == lists.size()) return NULL;
        
        while(lists.size() > 1) {
            lists.push_back(mergeTwoList(lists[0], lists[1]));
            lists.erase(lists.begin());
            lists.erase(lists.begin());
        }
        
        return lists[0];
    }
    
    ListNode* mergeTwoList(ListNode* l1, ListNode* l2) {
        if(NULL == l1) return l2;
        if(NULL == l2) return l1;
        
        if(l1->val < l2->val) {
            l1->next = mergeTwoList(l1->next, l2);
            return l1;
        }
        
        l2->next = mergeTwoList(l1, l2->next);
        return l2;
    }
};
